---
title: "Dynamics of aquatic and soil-derived bacteria in a temperate lake"
author: "Tajinder Singh, Nathan I. Wisnoski, and Jay T. Lennon"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    df_print: paged
  word_document: default
  pdf_document:
    fig_caption: yes
    keep_tex: yes
header-includes:
- \usepackage{array}
- \usepackage{graphics}
---
---


normal para text


# main header

## sub header

### sub-sub header

```{r setup, echo=FALSE}
knitr::opts_chunk$set(
  fig.width = 6,
  fig.align = "center",
  message = FALSE,
  warning = 'hide')
```

First, we'll load the packages we'll need for the analysis, as well as some other functions.

```{r packages, results='hide'}
# Import Required Packages

library(tidyverse)   
library(vegan)
library(viridis)
library(lubridate)
library(cluster)
library(dtwclust)




source("bin/mothur_tools.R")
se <- function(x, ...){sd(x, na.rm = TRUE)/sqrt(length(na.omit(x)))}
```

Next, we'll set the aesthetics of the figures we will produce

```{r figure_setup}
my.cols <- RColorBrewer::brewer.pal(n = 4, name = "Greys")[3:4]

# Set theme for figures in the paper
theme_set(theme_classic() + 
  theme(axis.title = element_text(size = 16),
        axis.title.x = element_text(margin = margin(t = 15, b = 15)),
        axis.title.y = element_text(margin = margin(l = 15, r = 15)),
        axis.text = element_text(size = 14),
        axis.text.x = element_text(margin = margin(t = 5)),
        axis.text.y = element_text(margin = margin(r = 5)),
        #axis.line.x = element_line(size = 1),
        #axis.line.y = element_line(size = 1),
        axis.line.x = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks.x = element_line(size = 1),
        axis.ticks.y = element_line(size= 1),
        axis.ticks.length = unit(.1, "in"),
        panel.border = element_rect(color = "black", fill = NA, size =1.5),
        legend.title = element_blank(),
        legend.text = element_text(size = 14),
        strip.text = element_text(size = 14),
        strip.background = element_blank()
        ))
```

## Import Data

Here, we read in the processed sequence files from mothur (shared and taxonomy) and a design of the sampling. We also load in the environmental data. We then remove the mock community from the dataset and ensure the the design and OTU table are aligned by row



```{r}
# Define Inputs
# Design = general design file for experiment
# shared = OTU table from mothur with sequence similarity clustering
# Taxonomy = Taxonomic information for each OTU
design <- "data/UL.design.txt"
shared <- "data/ul_resgrad.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.shared"
taxon  <- "data/ul_resgrad.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.0.03.cons.taxonomy"

# Import Design
design <- read.delim(design, header=T, row.names=1)

# Import Shared Files
OTUs <- read.otu(shared = shared, cutoff = "0.03")    # 97% Similarity

# Import Taxonomy
OTU.tax <- read.tax(taxonomy = taxon, format = "rdp")

#OTUs <- OTUs[str_which(rownames(OTUs), "RG"),]
OTUs <- OTUs[-which(rownames(OTUs) == "RGMockComm"),]

OTUs <- rrarefy(OTUs, min(rowSums(OTUs)))
OTUs.REL <- decostand(OTUs, "total")
```


# Are the "persistent" reservoir taxa really representative? Look over time...

```{r time_series, fig.asp=1}
# Subset to just the time series sites
UL.ts.OTUs <- OTUs[str_which(rownames(OTUs), "UL"),]

# make sure OTU table matches up with design order
UL.ts.design <- read_csv("data/UL_timeseries_design.csv")
UL.ts.OTUs <- UL.ts.OTUs[match(UL.ts.design$sample.name, rownames(UL.ts.OTUs)),]

# separate RNA and DNA dynamics
UL.ts.OTUs.RNA <- decostand(UL.ts.OTUs[which(UL.ts.design$sample.type == "RNA"),], method = "total")
UL.ts.OTUs.DNA <- decostand(UL.ts.OTUs[which(UL.ts.design$sample.type == "DNA"),], method = "total")

UL.ts.OTUs.DNA.PA <- decostand(UL.ts.OTUs.DNA + UL.ts.OTUs.RNA, "pa")
UL.ts.OTUs.RNA.PA <- decostand(UL.ts.OTUs.RNA, "pa")

env.ts.data <- read.table("data/ul-seedbank.env.txt", sep="\t", header=TRUE)
env.ts.data$date <- as.Date(parse_date_time(env.ts.data$date, "m d y"))
env.ts.data$doc[which(env.ts.data$doc == "**")] <- NA
env.ts.data$doc <- as.numeric(env.ts.data$doc)
summary(env.ts.data)
UL.ts.design <- left_join(UL.ts.design, env.ts.data[,c("sample.id", "date")])
env.ts.data <- env.ts.data[-which(!(env.ts.data$date %in% UL.ts.design$date)),]
```


```{r}
RGSoil.OTUs <- OTUs[str_which(rownames(OTUs), "RGSoil"),] 
in.soils <- RGSoil.OTUs[,which(colSums(RGSoil.OTUs) > 0)]

soil.taxa <- colnames(in.soils)
nonsoil.taxa <- colnames(RGSoil.OTUs[,which(colSums(RGSoil.OTUs) == 0)])

length(soil.taxa) + length(nonsoil.taxa) == ncol(OTUs)


max.abund.in.soils <- apply(decostand(RGSoil.OTUs, "total"), MARGIN = 2, max)
common.in.soils <- names(max.abund.in.soils[which(max.abund.in.soils >= 0.001)])
rare.in.soils <- names(max.abund.in.soils[which(max.abund.in.soils < 0.001)])
length(common.in.soils) + length(rare.in.soils) == ncol(OTUs)

# pull out time series of taxa in soils
UL.ts.toplot.RNA <- UL.ts.OTUs.RNA[,which(colMeans(UL.ts.OTUs.DNA.PA) > .2)] # present in half samples

OTUs.toplot.in.soil <- UL.ts.OTUs.RNA[, which(colnames(UL.ts.toplot.RNA) %in% soil.taxa)]

# pull out taxa not detected in soils
OTUs.toplot.not.in.soil <- UL.ts.OTUs.RNA[, which(colnames(UL.ts.toplot.RNA) %in% nonsoil.taxa)]

ncol(OTUs.toplot.in.soil) + ncol(OTUs.toplot.not.in.soil) == ncol(UL.ts.toplot.RNA)

otu_trends_to_plot <- cbind.data.frame(UL.ts.design[which(UL.ts.design$sample.type == "RNA"),], OTUs.toplot.in.soil) %>% as_tibble() %>% 
  gather(-sample.name, -sample.type, -sample.id, -date, key = OTU, value = rel_abund) %>% 
  mutate(soils = ifelse(OTU %in% nonsoil.taxa, "Absent from soils",
                   ifelse(OTU %in% common.in.soils, "Common in soils", "Rare in soils")))
otu_trends_to_plot %>% 
  ggplot(aes(x = date, y = rel_abund + 1e-4, group = OTU)) +
  geom_point(alpha = .1) + 
  geom_line(color = "blue",
            alpha = 0.5) +
  geom_vline(aes(xintercept = as_date("2013-07-15"))) +
  scale_y_log10() + 
  scale_x_date(labels = scales::date_format(format = "%b %y")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~soils, ncol = 1) +
  labs(x = "",
       y = "Relative abundance")
  

```



Many of them do appear to track the seasons quite well, suggesting there could be a seasonality component to the role of terrestrial inputs into the reservoir.


```{r}
otu_trends_to_plot %>% 
  group_by(OTU) %>% 
  filter(mean(rel_abund) > 1e-3) %>% 
  ggplot(aes(x = date, y = rel_abund + 1e-4, group = OTU, color = soils)) +
  geom_point(alpha = .1) + 
  geom_line(color = "blue",
            alpha = 0.5) +
  geom_line(stat = "smooth", se = FALSE, span = 0.5) +
  geom_vline(aes(xintercept = as_date("2013-07-15"))) +
  scale_y_log10() + 
  scale_x_date(labels = scales::date_format(format = "%b %y")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~OTU) +
  labs(x = "",
       y = "Relative abundance")

```



Proportion of Soil OTUs richness in the Seed bank, to be used later to identify 
soil OTUs dormancy and activity patterns

```{r}
SB.ts.OTUs.PA <- UL.ts.OTUs.DNA.PA-UL.ts.OTUs.RNA.PA
head(SB.ts.OTUs.PA[,1:10])

#create vector for seed bank richness

SB.ts.richness <- rowSums(SB.ts.OTUs.PA)

plot(SB.ts.richness, type = "l")

#obtaining soil OTU richness in SB

SB.ts.Soil.OTUs.PA <- subset(SB.ts.OTUs.PA,select = colnames(in.soils) )
SB.ts.Soil.richness <- rowSums(SB.ts.Soil.OTUs.PA)
identical(SB.ts.Soil.richness, SB.ts.Soil.richness)


png("figures/sbsoilrichness.png", width = 8, height = 6, res= 500, units = "in")
plot(SB.ts.Soil.richness/SB.ts.richness, type= "l")
dev.off(which = 2)
```


Making a smooth line graph for soil richness

```{r}
#making a data frame for proportion of soil OTUs in SB

SB.ts.Soil.Prop <- tibble(sample.id= env.ts.data$sample.id, date= env.ts.data$date, Soil.Prop= SB.ts.Soil.richness/SB.ts.richness)

#plotting proportion over time

sb.soil.richness.sm <- ggplot(SB.ts.Soil.Prop, aes(x= date, y= Soil.Prop))+
  geom_point()+
  geom_smooth()
ggsave(filename = "figures/sbsoilprop.pdf", plot = sb.soil.richness.sm, height = 6, width = 8) 

```








Classifying Middle OTUs in RG samples, the classification will help focus on a smaller
section of the OTUs closer to the Time series collection to get a better
activity representation instead of far way points which might be too different.

```{r}

RG.middle.OTU <-OTUs.REL[c("RGD08", "RGD09", "RGD10", "RGD11", "RGc08", "RGc09", "RGc10", "RGc11"),]


#OTUs always active
RG.middle.RNA <- as.data.frame(t(colMeans(RG.middle.OTU[str_which(rownames(RG.middle.OTU), "RGc"), ])))
RG.middle.Ac <- RG.middle.RNA[, which(RG.middle.RNA[1, ] > 0)]
RG.avg.ac<- colnames(RG.middle.Ac)
RG.avg.soil.ac <- RG.middle.Ac[, which(colnames(RG.middle.Ac) %in% soil.taxa)]

#OTUs never active
RG.middle.DNA <- as.data.frame(t(colMeans(RG.middle.OTU[str_which(rownames(RG.middle.OTU), "RGD"),])))
RG.middle.sb <- RG.middle.DNA |> 
  select(where(~. >0)) |> 
  select(!matches(RG.avg.ac))
RG.avg.sb <- colnames(RG.middle.sb)
RG.avg.soil.sb <- RG.middle.sb[, which(colnames(RG.middle.sb) %in% soil.taxa)]

 
```



Classifying middle OTUs based on relative abundance
classification helps to see if different classes behave differently in activity patterns
```{r}


RG.clsfd.ac <- RG.middle.Ac |>
  t() |>
  as_tibble() |> 
  rename(rel.ab = V1) |> 
  mutate(ab.class = if_else(rel.ab< exp(-10), 6, 
                            if_else(rel.ab < exp(-9), 5, 
                            if_else(rel.ab < exp(-8), 4, 
                                    if_else(rel.ab < exp(-6), 3, 
                                            if_else(rel.ab < exp(-4), 2, 
                                                    if_else(rel.ab < exp(-2), 1, 12)))))))


row.names(RG.clsfd.ac) <- names(RG.middle.Ac)
RG.clsfd.ac<- rownames_to_column(RG.clsfd.ac, var = "OTU")

RG.clsfd.sb<- RG.middle.sb |>
  t() |> 
  as_tibble() |> 
  rename(rel.ab = V1) |> 
  mutate(ab.class = if_else(rel.ab< exp(-10), 6, 
                            if_else(rel.ab < exp(-9), 5, 
                            if_else(rel.ab < exp(-8), 4, 
                                    if_else(rel.ab < exp(-6), 3, 
                                            if_else(rel.ab < exp(-4), 2, 
                                                    if_else(rel.ab < exp(-2), 1, 12)))))))

row.names(RG.clsfd.sb) <- names(RG.middle.sb)
RG.clsfd.sb<- rownames_to_column(RG.clsfd.sb, var = "OTU")
```





changing wide form to long form, for code and plot efficiency
```{r}
OTU.ts.long<- UL.ts.OTUs.RNA |> as_tibble() |> 
  rownames_to_column( var= "sample.id" ) |> 
  mutate(sample.id= as.integer(sample.id)) |> 
  pivot_longer(names_to = "OTU", values_to = "relative.abundance", cols = -sample.id) |> 
  left_join(env.ts.data, by= "sample.id" )

OTU.ts.long |> filter(OTU %in% RG.avg.ac) |> 
  filter( OTU %in% soil.taxa) |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()

```





Graphing Soil OTUs based on classification, to get a more readable picture
possibly to see seasonality trends
```{r}

OTU.ts.long |> filter(OTU %in% RG.avg.ac) |> 
  filter(OTU %in% soil.taxa) |>
  left_join(RG.clsfd.ac, by = "OTU") |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()+
  facet_wrap(~ab.class)



OTU.ts.long |> filter(OTU %in% RG.avg.ac) |> 
  filter(!OTU %in% soil.taxa) |>
  left_join(RG.clsfd.ac, by = "OTU") |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()+
  facet_wrap(~ab.class)




#getting taxonomy of different rel. abundance classes
clsfd.ac.1<- filter(RG.clsfd.ac, ab.class == 1)
so.ac.1<- OTU.tax |>  
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.1$OTU)

aq.ac.1<- OTU.tax |> 
  filter(!OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.1$OTU)

clsfd.ac.2<- filter(RG.clsfd.ac, ab.class == 2)
so.ac.2<- OTU.tax |> 
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.2$OTU)

aq.ac.2<- OTU.tax |>  
  filter(!OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.2$OTU)

clsfd.ac.3<- filter(RG.clsfd.ac, ab.class == 3)
so.ac.3<- OTU.tax |>  
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.3$OTU)

aq.ac.3<- OTU.tax |>  
  filter(!OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.3$OTU)

clsfd.ac.4<- filter(RG.clsfd.ac, ab.class == 4)
so.ac.4<- OTU.tax |>  
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.4$OTU)

aq.ac.4<- OTU.tax |> 
  filter(!OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.4$OTU)

clsfd.ac.5<- filter(RG.clsfd.ac, ab.class == 5)
so.ac.5<- OTU.tax |> 
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.5$OTU)

aq.ac.5<- OTU.tax |> 
  filter(!OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.5$OTU)

clsfd.ac.6<- filter(RG.clsfd.ac, ab.class == 6)
so.ac.6<- OTU.tax |> 
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.6$OTU)

aq.ac.6<- OTU.tax |> 
  filter(!OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.6$OTU)
  
```



Plotting the same in seed bank, *caution: seed bank is purely theoretical and might 
not give an accurate representation
```{r}
OTU.ts.long |> filter(OTU %in% RG.avg.sb) |> 
  filter(OTU %in% soil.taxa) |>
  left_join(RG.clsfd.sb, by = "OTU") |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()+
  facet_wrap(~ab.class)

OTU.ts.long |> filter(OTU %in% RG.avg.sb) |> 
  filter(!OTU %in% soil.taxa) |>
  left_join(RG.clsfd.sb, by = "OTU") |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()+
  facet_wrap(~ab.class)

#getting taxonomy of different rel. abundance classes

clsfd.sb.1<- filter(RG.clsfd.sb, ab.class == 1)
so.sb.1<- OTU.tax |> 
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.sb.1$OTU)

aq.sb.1<- OTU.tax |> 
  filter(OTU %in% clsfd.sb.1$OTU) |> 
  filter(!OTU %in% soil.taxa)

clsfd.sb.2<- filter(RG.clsfd.sb, ab.class == 2)
so.sb.2<- OTU.tax |>
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.sb.2$OTU)

aq.sb.2<- OTU.tax |> 
  filter(OTU %in% clsfd.sb.2$OTU) |> 
  filter(!OTU %in% soil.taxa)

clsfd.sb.3<- filter(RG.clsfd.sb, ab.class == 3)
so.sb.3<- OTU.tax |>
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.sb.3$OTU)

aq.sb.3<- OTU.tax |> 
  filter(OTU %in% clsfd.sb.3$OTU) |> 
  filter(!OTU %in% soil.taxa)

clsfd.sb.4<- filter(RG.clsfd.sb, ab.class == 4)
so.sb.4<- OTU.tax |>
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.sb.4$OTU)

aq.sb.4<- OTU.tax |> 
  filter(OTU %in% clsfd.sb.4$OTU) |> 
  filter(!OTU %in% soil.taxa)

clsfd.sb.5<- filter(RG.clsfd.sb, ab.class == 5)
so.sb.5<- OTU.tax |> 
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.sb.5$OTU)

aq.sb.5<- OTU.tax |> 
  filter(OTU %in% clsfd.sb.5$OTU) |> 
  filter(!OTU %in% soil.taxa)

clsfd.sb.6<- filter(RG.clsfd.sb, ab.class == 6)
so.sb.6<- OTU.tax |> 
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.sb.6$OTU)

aq.sb.6<- OTU.tax |> 
  filter(OTU %in% clsfd.sb.6$OTU) |> 
  filter(!OTU %in% soil.taxa)

  

```

 


OTUs Filtered by abundance in soil, to further filter some noise and be able to 
see better activity patterns and seasonality. Also, if differnt classes behaved differently.
Thre idea was that rare in soils would be more abundand in aquatic communities

```{r}
OTU.ts.long |> filter(OTU %in% RG.avg.ac) |> 
  filter(OTU %in% common.in.soils) |>
  left_join(RG.clsfd.sb, by = "OTU") |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()+
  facet_wrap(~ab.class)

OTU.ts.long |> filter(OTU %in% RG.avg.ac) |> 
  filter(OTU %in% rare.in.soils) |>
  left_join(RG.clsfd.sb, by = "OTU") |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()+
  facet_wrap(~ab.class)

OTU.ts.long |> filter(OTU %in% RG.avg.sb) |> 
  filter(OTU %in% common.in.soils) |>
  left_join(RG.clsfd.sb, by = "OTU") |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()+
  facet_wrap(~ab.class)

OTU.ts.long |> filter(OTU %in% RG.avg.sb) |> 
  filter(OTU %in% rare.in.soils) |>
  left_join(RG.clsfd.sb, by = "OTU") |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()+
  facet_wrap(~ab.class)
```



Looking into seedbank dynamics classified by dominance in soil samples.
To see if different dominant classes are present in the seed bank.

```{r}
#making seedbank long form

SB.ts.OTUs <- colnames(SB.ts.OTUs.PA)[colSums(SB.ts.OTUs.PA) > 0]
UL.ts.OTUs.sb<- UL.ts.OTUs.DNA[, colnames(UL.ts.OTUs.DNA) %in% SB.ts.OTUs]


OTU.ts.long.sb<- UL.ts.OTUs.sb |>
  as_tibble() |> 
  rownames_to_column( var= "sample.id" ) |> 
  mutate(sample.id= as.integer(sample.id)) |> 
  pivot_longer(names_to = "OTU", values_to = "relative.abundance", cols = -sample.id) |> 
  left_join(env.ts.data, by= "sample.id" )

OTU.ts.long.sb |> filter(OTU %in% RG.avg.ac) |> 
  filter(OTU %in% common.in.soils) |>
  left_join(RG.clsfd.sb, by = "OTU") |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()+
  facet_wrap(~ab.class)

OTU.ts.long.sb |> filter(OTU %in% RG.avg.ac) |> 
  filter(OTU %in% rare.in.soils) |>
  left_join(RG.clsfd.sb, by = "OTU") |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()+
  facet_wrap(~ab.class)

OTU.ts.long.sb |> filter(OTU %in% RG.avg.sb) |> 
  filter(OTU %in% common.in.soils) |>
  left_join(RG.clsfd.sb, by = "OTU") |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()+
  facet_wrap(~ab.class)

OTU.ts.long.sb |> filter(OTU %in% RG.avg.sb) |> 
  filter(OTU %in% rare.in.soils) |>
  left_join(RG.clsfd.sb, by = "OTU") |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()+
  facet_wrap(~ab.class)
```

  




attempting to get sorted RNA and DNA presence absences to recognise clusters.
Checking to see what fraction of OTUs are active at any given time point.
To recognize if a higher or lower fraction of the OTUs are active at different times
possibly hinting at seasonality

```{r}

X0<- as.data.frame(UL.ts.OTUs.RNA.PA[,colSums(UL.ts.OTUs.RNA.PA)>0]) 
X<- data_frame(fraction= rowSums(UL.ts.OTUs.RNA.PA[,colSums(UL.ts.OTUs.RNA.PA)>0])/11824) #only active OTUs
plot(x= rownames(X), y= X$fraction, type = "l")
X1<- data_frame(fraction= rowSums(UL.ts.OTUs.RNA.PA)/83343) #all OTUs
plot(x= rownames(X1), y= X1$fraction, type = "l")

 X2 <- X0 |> 
  subset(X0 %in% rare.in.soils)
 
```


Trying to see the same fractional activity patterns in RNA, DNA, SB datasets
The significant difference between OTUs that were ever present vs all OTUs raises the
question of wether those other OTUs should even be focused on that were never even detected in the data sets
If not detected then, where are they coming from????
 
```{r}
X<- data_frame(fraction= rowSums(UL.ts.OTUs.RNA.PA[,colSums(UL.ts.OTUs.RNA.PA)>0])/11824) #Present
plot(x= rownames(X), y= X$fraction, type = "l")
X1<- data_frame(fraction= rowSums(UL.ts.OTUs.RNA.PA)/83343) #All
plot(x= rownames(X1), y= X1$fraction, type = "l")

Y<- data_frame(fraction= rowSums(UL.ts.OTUs.DNA.PA[,colSums(UL.ts.OTUs.DNA.PA)>0])/19399) #Present
plot(x= rownames(Y), y= Y$fraction, type = "l")
Y1<- data_frame(fraction= rowSums(UL.ts.OTUs.DNA.PA)/83343)#ALl
plot(x= rownames(Y1), y= Y1$fraction, type = "l")

Z<- data_frame(fraction= rowSums(SB.ts.OTUs.PA[,colSums(SB.ts.OTUs.PA)>0])/12130) #Present
plot(x= rownames(Z), y= Z$fraction, type = "l")
Z1<- data_frame(fraction= rowSums(SB.ts.OTUs.PA)/83343) #All
plot(x= rownames(Z1), y= Z1$fraction, type = "l")
```
 
  
Plotting a cluster table to find best fits for patterns in ts.RNA 

```{r}

# Create an empty table to store the cluster results
cluster_table <- data.frame(ID = 1:50, Cluster = NA)

Q<- t(UL.ts.OTUs.RNA.PA[ ,colnames(UL.ts.OTUs.RNA.PA) %in% RG.avg.ac])
Q2<- t(data_frame(UL.ts.OTUs.RNA.PA[,colSums(UL.ts.OTUs.RNA.PA)>0]))
Q3<- as.data.frame(UL.ts.OTUs.RNA[,colSums(UL.ts.OTUs.RNA)>0])

for (k in 2:50) {
  # Calculate the distance matrix
  dist_matrix <- vegdist(Q2, method = "jaccard")
  
  # Check for missing or infinite values
  if (any(is.na(dist_matrix)) || any(is.infinite(dist_matrix))) {
    # Handle missing or infinite values
    dist_matrix[is.na(dist_matrix) | is.infinite(dist_matrix)] <- 0  # Replace with 0 or any other appropriate value
  }
  
  # Perform hierarchical clustering
  hclust_result <- hclust(dist_matrix, method = "complete")
  
  # Obtain the clusters for the current iteration
  clusters <- cutree(hclust_result, k = k)
  sill<- silhouette(clusters, dist = dist_matrix)
  
  # Assign cluster names to the corresponding IDs
  names(clusters) <- colnames(UL.ts.OTUs.RNA.PA[, colSums(UL.ts.OTUs.RNA.PA) > 0])
  
  # Store the cluster results in the table
  cluster_table$Cluster[k] <- summary(sill)$avg.width
}


plot(cluster_table)

write.csv(cluster_table, file= "/Users/tj/git/ul-spacetime/cluster_table/clst.ts.rna.p.csv", row.names = FALSE)

assign("clst.ts.rna.p", read.csv("/Users/tj/git/ul-spacetime/cluster_table/clst.ts.rna.p.csv"))

plot(clst.ts.rna.p)
```


Plotting a cluster table to find best fits for patterns in RG.avg
Made a loop to determine which cluster number is the best fit for the data set

```{r}
# Create an empty table to store the cluster results
cluster_table.avg <- data.frame(ID = 1:50, Cluster = NA)

Q<- t(UL.ts.OTUs.RNA.PA[ ,colnames(UL.ts.OTUs.RNA.PA) %in% RG.avg.ac])

for (k in 2:50) {
  # Calculate the distance matrix
  dist_matrix <- vegdist(Q, method = "jaccard")
  
  # Check for missing or infinite values
  if (any(is.na(dist_matrix)) || any(is.infinite(dist_matrix))) {
    # Handle missing or infinite values
    dist_matrix[is.na(dist_matrix) | is.infinite(dist_matrix)] <- 0  # Replace with 0 or any other appropriate value
  }
  
  # Perform hierarchical clustering
  hclust_result <- hclust(dist_matrix, method = "complete")
  
  # Obtain the clusters for the current iteration
  clusters <- cutree(hclust_result, k = k)
  sill<- silhouette(clusters, dist = dist_matrix)
  
  # Assign cluster names to the corresponding IDs
  names(clusters) <- colnames(UL.ts.OTUs.RNA.PA[, colSums(UL.ts.OTUs.RNA.PA) %in% RG.avg.ac])
  
  # Store the cluster results in the table
  cluster_table.avg$Cluster[k] <- summary(sill)$avg.width
}


plot(cluster_table.avg)

write.csv(cluster_table.avg, file= "/Users/tj/git/ul-spacetime/cluster_table/clst.ts.rna.avg.csv", row.names = FALSE)

assign("clst.ts.rna.p", read.csv("/Users/tj/git/ul-spacetime/cluster_table/clst.ts.rna.avg.csv"))

plot(clst.ts.rna.p)


```




Making clusters for k=18,found to be best fir from the cluster table created previously.
The aim of clustering was to see different types of activity pattern. Hopefully to recognize
compensation VS complimentary activity patterns in the community. But ended up giving a clearer
visual of seasonality trends.
```{r}
 dist_matrix <-vegdist(Q2, method = "jaccard")

 # Check for missing or infinite values
  if (any(is.na(dist_matrix)) || any(is.infinite(dist_matrix))) {
    # Handle missing or infinite values
    dist_matrix[is.na(dist_matrix) | is.infinite(dist_matrix)] <- 0 } # Replace with 0 or any other appropriate value
    
    # Perform hierarchical clustering
  hclust_result <- hclust(dist_matrix, method = "complete")
  clusters <- cutree(hclust_result, k = 18)
  names(clusters) <- colnames(UL.ts.OTUs.RNA.PA[, colSums(UL.ts.OTUs.RNA.PA) > 0])
  
df<- as.data.frame(t(Q2))
names(df) <- colnames(UL.ts.OTUs.RNA.PA[, colSums(UL.ts.OTUs.RNA.PA) > 0])


clusters.df<- as.data.frame(clusters)
clusters.df$OTU<- rownames(clusters.df)
clusters.df<- clusters.df |> 
  mutate(clusters= as.factor(clusters))
clusters.df |> group_by(clusters) |> 
  count(OTU) |> 
  summarise(sum(count))

OTU.ts.long |> filter(OTU %in% colnames(df)) |> 
  left_join(clusters.df, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters)

OTU.ts.long |> filter(OTU %in% RG.avg.sb) |> 
  filter(OTU %in% rare.in.soils) |>
  left_join(RG.clsfd.sb, by = "OTU") |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()+
  facet_wrap(~ab.class)
```



Filtering based on abi=undance classes to reduce noise and see the patterns better
Re-clustering after filtering based on abundance class 1
```{r}
df<- as.data.frame(t(Q2))
names(df) <- colnames(UL.ts.OTUs.RNA.PA[, colSums(UL.ts.OTUs.RNA.PA) > 0])
df.1<- df |> select(any_of(clsfd.ac.1$OTU))
dist_matrix.1<- vegdist(t(df.1), method= "jaccard")


# Check for missing or infinite values
if (any(is.na(dist_matrix.1)) || any(is.infinite(dist_matrix.1))) {
  # Handle missing or infinite values
  dist_matrix[is.na(dist_matrix) | is.infinite(dist_matrix)] <- 0  # Replace with 0 or any other appropriate value
}

# Perform hierarchical clustering
hclust_result.1 <- hclust(dist_matrix.1, method = "complete")

# Obtain the clusters for the current iteration
clusters.1 <- cutree(hclust_result.1, k = 3)
sill.1<- silhouette(clusters.1, dist = dist_matrix.1)

# Assign cluster names to the corresponding IDs
names(clusters.1) <- colnames(select(df, any_of(clsfd.ac.1$OTU)))

summary(sill.1)$avg.width

clusters.df.1<- as.data.frame(clusters.1)
clusters.df.1$OTU<- rownames(clusters.df.1)

           
                                        

OTU.ts.long |> filter(OTU %in% colnames(df.1)) |> 
  left_join(clusters.df.1, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters.1)


```







Re-clustering after filtering based on abundance class 2
```{r}
df.2<- df |> select(any_of(clsfd.ac.2$OTU))
dist_matrix.2<- vegdist(t(df.2), method= "jaccard")


# Check for missing or infinite values
if (any(is.na(dist_matrix.2)) || any(is.infinite(dist_matrix.2))) {
  # Handle missing or infinite values
  dist_matrix[is.na(dist_matrix.2) | is.infinite(dist_matrix.2)] <- 0  # Replace with 0 or any other appropriate value
}

# Perform hierarchical clustering
hclust_result.2 <- hclust(dist_matrix.2, method = "complete")

# Obtain the clusters for the current iteration
clusters.2 <- cutree(hclust_result.2, k = 4)
sill.2<- silhouette(clusters.2, dist = dist_matrix.2)

# Assign cluster names to the corresponding IDs
names(clusters.2) <- colnames(select(df, any_of(clsfd.ac.2$OTU)))

summary(sill.2)$avg.width

clusters.df.2<- as.data.frame(clusters.2)
clusters.df.2$OTU<- rownames(clusters.df.2)

           
                                        

OTU.ts.long |> filter(OTU %in% colnames(df.2)) |> 
  left_join(clusters.df.2, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters.2, scales = "free_y")


```






Re-clustering after filtering based on abundance class 3
```{r}
df.3<- df |> select(any_of(clsfd.ac.3$OTU))
dist_matrix.3<- vegdist(t(df.3), method= "jaccard")


# Check for missing or infinite values
if (any(is.na(dist_matrix.3)) || any(is.infinite(dist_matrix.3))) {
  # Handle missing or infinite values
  dist_matrix[is.na(dist_matrix.3) | is.infinite(dist_matrix.3)] <- 0  # Replace with 0 or any other appropriate value
}

# Perform hierarchical clustering
hclust_result.3 <- hclust(dist_matrix.3, method = "complete")

# Obtain the clusters for the current iteration
clusters.3 <- cutree(hclust_result.3, k = 5)
sill.3<- silhouette(clusters.3, dist = dist_matrix.3)

# Assign cluster names to the corresponding IDs
names(clusters.3) <- colnames(select(df, any_of(clsfd.ac.3$OTU)))

summary(sill.3)$avg.width

clusters.df.3<- as.data.frame(clusters.3)
clusters.df.3$OTU<- rownames(clusters.df.3)

           
                                        

OTU.ts.long |> filter(OTU %in% colnames(df.3)) |> 
  left_join(clusters.df.3, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters.3)


```





Re-clustering after filtering based on abundance class 4
```{r}
df.4<- df |> select(any_of(clsfd.ac.4$OTU))
dist_matrix.4<- vegdist(t(df.4), method= "jaccard")


# Check for missing or infinite values
if (any(is.na(dist_matrix.4)) || any(is.infinite(dist_matrix.4))) {
  # Handle missing or infinite values
  dist_matrix[is.na(dist_matrix.4) | is.infinite(dist_matrix.4)] <- 0  # Replace with 0 or any other appropriate value
}

# Perform hierarchical clustering
hclust_result.4 <- hclust(dist_matrix.4, method = "complete")

# Obtain the clusters for the current iteration
clusters.4 <- cutree(hclust_result.4, k = 4)
sill.4<- silhouette(clusters.4, dist = dist_matrix.4)

# Assign cluster names to the corresponding IDs
names(clusters.4) <- colnames(select(df, any_of(clsfd.ac.4$OTU)))

summary(sill.4)$avg.width

clusters.df.4<- as.data.frame(clusters.4)
clusters.df.4$OTU<- rownames(clusters.df.4)

           
                                        

OTU.ts.long |> filter(OTU %in% colnames(df.4)) |> 
  left_join(clusters.df.4, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters.4)


```




Re-clustering after filtering based on abundance class 5
```{r}
df.5<- df |> select(any_of(clsfd.ac.5$OTU))
dist_matrix.5<- vegdist(t(df.5), method= "jaccard")


# Check for missing or infinite values
if (any(is.na(dist_matrix.5)) || any(is.infinite(dist_matrix.5))) {
  # Handle missing or infinite values
  dist_matrix[is.na(dist_matrix.5) | is.infinite(dist_matrix.5)] <- 0  # Replace with 0 or any other appropriate value
}

# Perform hierarchical clustering
hclust_result.5 <- hclust(dist_matrix.5, method = "complete")

# Obtain the clusters for the current iteration
clusters.5 <- cutree(hclust_result.5, k = 2)
sill.5<- silhouette(clusters.5, dist = dist_matrix.5)

# Assign cluster names to the corresponding IDs
names(clusters.5) <- colnames(select(df, any_of(clsfd.ac.5$OTU)))

summary(sill.5)$avg.width

clusters.df.5<- as.data.frame(clusters.5)
clusters.df.5$OTU<- rownames(clusters.df.5)

           
                                        

OTU.ts.long |> filter(OTU %in% colnames(df.5)) |> 
  left_join(clusters.df.5, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters.5)

```




Re-clustering after filtering based on abundance class 6
```{r}
df.6<- df |> select(any_of(clsfd.ac.6$OTU))
dist_matrix.6<- vegdist(t(df.6), method= "jaccard")


# Check for missing or infinite values
if (any(is.na(dist_matrix.6)) || any(is.infinite(dist_matrix.6))) {
  # Handle missing or infinite values
  dist_matrix[is.na(dist_matrix.6) | is.infinite(dist_matrix.6)] <- 0  # Replace with 0 or any other appropriate value
}

# Perform hierarchical clustering
hclust_result.6 <- hclust(dist_matrix.6, method = "complete")

# Obtain the clusters for the current iteration
clusters.6 <- cutree(hclust_result.6, k = 5)
sill.6<- silhouette(clusters.6, dist = dist_matrix.6)

# Assign cluster names to the corresponding IDs
names(clusters.6) <- colnames(select(df, any_of(clsfd.ac.6$OTU)))

summary(sill.6)$avg.width

clusters.df.6<- as.data.frame(clusters.6)
clusters.df.6$OTU<- rownames(clusters.df.6)

           
                                        

OTU.ts.long |> filter(OTU %in% colnames(df.6)) |> 
  left_join(clusters.df.6, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters.6)

```



Trying the same thing on "Seedbank"
```{r}
df.1c<- Q3 |> select(any_of(clsfd.sb.5$OTU))
dist_matrix.1c<- vegdist(t(df.1c), method= "jaccard")


# Check for missing or infinite values
if (any(is.na(dist_matrix.1c)) || any(is.infinite(dist_matrix.1c))) {
  # Handle missing or infinite values
  dist_matrix[is.na(dist_matrix.1c) | is.infinite(dist_matrix.1c)] <- 0  # Replace with 0 or any other appropriate value
}

# Perform hierarchical clustering
hclust_result.1c <- hclust(dist_matrix.1c, method = "complete")

# Obtain the clusters for the current iteration
clusters.1c <- cutree(hclust_result.1c, k = 3)
sill.1c<- silhouette(clusters.1c, dist = dist_matrix.1c)

# Assign cluster names to the corresponding IDs
names(clusters.1c) <- colnames(select(Q3, any_of(clsfd.ac.1$OTU)))

summary(sill.1c)$avg.width

clusters.df.1c<- as.data.frame(clusters.1c)
clusters.df.1c$OTU<- rownames(clusters.df.1c)

           
                                        

OTU.ts.long |> filter(OTU %in% colnames(df.1c)) |> 
  left_join(clusters.df.1c, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters.1c)

```


Trying clustering based on rel. abundance
```{r}
R2<- t(data_frame(UL.ts.OTUs.RNA[,colSums(UL.ts.OTUs.RNA.PA)>0]))

df.4r<- df |> select(any_of(clsfd.ac.4$OTU))
dist_matrix.4r<- vegdist(t(df.4r), method= "jaccard")


# Check for missing or infinite values
if (any(is.na(dist_matrix.4r)) || any(is.infinite(dist_matrix.4r))) {
  # Handle missing or infinite values
  dist_matrix[is.na(dist_matrix.4r) | is.infinite(dist_matrix.4r)] <- 0  # Replace with 0 or any other appropriate value
}

# Perform hierarchical clustering
hclust_result.4r <- hclust(dist_matrix.4r, method = "complete")

# Obtain the clusters for the current iteration
clusters.4r <- cutree(hclust_result.4r, k = 4)
sill.4r<- silhouette(clusters.4r, dist = dist_matrix.4r)

# Assign cluster names to the corresponding IDs
names(clusters.4r) <- colnames(select(df.4r, any_of(clsfd.ac.4$OTU)))

summary(sill.4r)$avg.width

clusters.df.4r<- as.data.frame(clusters.4r)
clusters.df.4r$OTU<- rownames(clusters.df.4r)

           
                                        

OTU.ts.long |> filter(OTU %in% colnames(df.4r)) |> 
  left_join(clusters.df.4r, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters.4r)

```

