---
title: "Dynamics of aquatic and soil-derived bacteria in a temperate lake"
author: "Tajinder Singh, Nathan I. Wisnoski, and Jay T. Lennon"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    df_print: paged
  word_document: default
  pdf_document:
    fig_caption: yes
    keep_tex: yes
header-includes:
- \usepackage{array}
- \usepackage{graphics}
---
---


normal para text


# main header

## sub header

### sub-sub header

```{r setup, echo=FALSE}
knitr::opts_chunk$set(
  fig.width = 6,
  fig.align = "center",
  message = FALSE,
  warning = 'hide')
```

First, we'll load the packages we'll need for the analysis, as well as some other functions.

```{r packages, results='hide'}
# Import Required Packages

library(tidyverse)   
library(vegan)
library(viridis)
library(lubridate)
library(cluster)
library(dtwclust)




source("bin/mothur_tools.R")
se <- function(x, ...){sd(x, na.rm = TRUE)/sqrt(length(na.omit(x)))}
```

Next, we'll set the aesthetics of the figures we will produce

```{r figure_setup}
my.cols <- RColorBrewer::brewer.pal(n = 4, name = "Greys")[3:4]

# Set theme for figures in the paper
theme_set(theme_classic() + 
  theme(axis.title = element_text(size = 16),
        axis.title.x = element_text(margin = margin(t = 15, b = 15)),
        axis.title.y = element_text(margin = margin(l = 15, r = 15)),
        axis.text = element_text(size = 14),
        axis.text.x = element_text(margin = margin(t = 5)),
        axis.text.y = element_text(margin = margin(r = 5)),
        #axis.line.x = element_line(size = 1),
        #axis.line.y = element_line(size = 1),
        axis.line.x = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks.x = element_line(size = 1),
        axis.ticks.y = element_line(size= 1),
        axis.ticks.length = unit(.1, "in"),
        panel.border = element_rect(color = "black", fill = NA, size =1.5),
        legend.title = element_blank(),
        legend.text = element_text(size = 14),
        strip.text = element_text(size = 14),
        strip.background = element_blank()
        ))
```

## Import Data

Here, we read in the processed sequence files from mothur (shared and taxonomy) and a design of the sampling. We also load in the environmental data. We then remove the mock community from the dataset and ensure the the design and OTU table are aligned by row



```{r}
# Define Inputs
# Design = general design file for experiment
# shared = OTU table from mothur with sequence similarity clustering
# Taxonomy = Taxonomic information for each OTU
design <- "data/UL.design.txt"
shared <- "data/ul_resgrad.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.shared"
taxon  <- "data/ul_resgrad.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.opti_mcc.0.03.cons.taxonomy"

# Import Design
design <- read.delim(design, header=T, row.names=1)

# Import Shared Files
OTUs <- read.otu(shared = shared, cutoff = "0.03")    # 97% Similarity

# Import Taxonomy
OTU.tax <- read.tax(taxonomy = taxon, format = "rdp")

#OTUs <- OTUs[str_which(rownames(OTUs), "RG"),]
OTUs <- OTUs[-which(rownames(OTUs) == "RGMockComm"),]

OTUs <- rrarefy(OTUs, min(rowSums(OTUs)))
OTUs.REL <- decostand(OTUs, "total")
```


# Are the "persistent" reservoir taxa really representative? Look over time...

```{r time_series, fig.asp=1}
# Subset to just the time series sites
UL.ts.OTUs <- OTUs[str_which(rownames(OTUs), "UL"),]

# make sure OTU table matches up with design order
UL.ts.design <- read_csv("data/UL_timeseries_design.csv")
UL.ts.OTUs <- UL.ts.OTUs[match(UL.ts.design$sample.name, rownames(UL.ts.OTUs)),]

# separate RNA and DNA dynamics
UL.ts.OTUs.RNA <- decostand(UL.ts.OTUs[which(UL.ts.design$sample.type == "RNA"),], method = "total")
UL.ts.OTUs.DNA <- decostand(UL.ts.OTUs[which(UL.ts.design$sample.type == "DNA"),], method = "total")

UL.ts.OTUs.DNA.PA <- decostand(UL.ts.OTUs.DNA + UL.ts.OTUs.RNA, "pa")
UL.ts.OTUs.RNA.PA <- decostand(UL.ts.OTUs.RNA, "pa")

env.ts.data <- read.table("data/ul-seedbank.env.txt", sep="\t", header=TRUE)
env.ts.data$date <- as.Date(parse_date_time(env.ts.data$date, "m d y"))
env.ts.data$doc[which(env.ts.data$doc == "**")] <- NA
env.ts.data$doc <- as.numeric(env.ts.data$doc)
summary(env.ts.data)
UL.ts.design <- left_join(UL.ts.design, env.ts.data[,c("sample.id", "date")])
env.ts.data <- env.ts.data[-which(!(env.ts.data$date %in% UL.ts.design$date)),]
```


```{r}
RGSoil.OTUs <- OTUs[str_which(rownames(OTUs), "RGSoil"),] 
in.soils <- RGSoil.OTUs[,which(colSums(RGSoil.OTUs) > 0)]

soil.taxa <- colnames(in.soils)
nonsoil.taxa <- colnames(RGSoil.OTUs[,which(colSums(RGSoil.OTUs) == 0)])

length(soil.taxa) + length(nonsoil.taxa) == ncol(OTUs)


max.abund.in.soils <- apply(decostand(RGSoil.OTUs, "total"), MARGIN = 2, max)
common.in.soils <- names(max.abund.in.soils[which(max.abund.in.soils >= 0.001)])
rare.in.soils <- names(max.abund.in.soils[which(max.abund.in.soils < 0.001)])
length(common.in.soils) + length(rare.in.soils) == ncol(OTUs)

# pull out time series of taxa in soils
UL.ts.toplot.RNA <- UL.ts.OTUs.RNA[,which(colMeans(UL.ts.OTUs.DNA.PA) > .2)] # present in half samples

OTUs.toplot.in.soil <- UL.ts.OTUs.RNA[, which(colnames(UL.ts.toplot.RNA) %in% soil.taxa)]

# pull out taxa not detected in soils
OTUs.toplot.not.in.soil <- UL.ts.OTUs.RNA[, which(colnames(UL.ts.toplot.RNA) %in% nonsoil.taxa)]

ncol(OTUs.toplot.in.soil) + ncol(OTUs.toplot.not.in.soil) == ncol(UL.ts.toplot.RNA)

otu_trends_to_plot <- cbind.data.frame(UL.ts.design[which(UL.ts.design$sample.type == "RNA"),], OTUs.toplot.in.soil) %>% as_tibble() %>% 
  gather(-sample.name, -sample.type, -sample.id, -date, key = OTU, value = rel_abund) %>% 
  mutate(soils = ifelse(OTU %in% nonsoil.taxa, "Absent from soils",
                   ifelse(OTU %in% common.in.soils, "Common in soils", "Rare in soils")))
otu_trends_to_plot %>% 
  ggplot(aes(x = date, y = rel_abund + 1e-4, group = OTU)) +
  geom_point(alpha = .1) + 
  geom_line(color = "blue",
            alpha = 0.5) +
  geom_vline(aes(xintercept = as_date("2013-07-15"))) +
  scale_y_log10() + 
  scale_x_date(labels = scales::date_format(format = "%b %y")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~soils, ncol = 1) +
  labs(x = "",
       y = "Relative abundance")
  

```




Proportion of Soil OTUs richness in the Seed bank, to be used later to identify 
soil OTUs dormancy and activity patterns

```{r}
SB.ts.OTUs.PA <- UL.ts.OTUs.DNA.PA-UL.ts.OTUs.RNA.PA
head(SB.ts.OTUs.PA[,1:10])

#create vector for seed bank richness

SB.ts.richness <- rowSums(SB.ts.OTUs.PA)

plot(SB.ts.richness, type = "l")

#obtaining soil OTU richness in SB

SB.ts.Soil.OTUs.PA <- subset(SB.ts.OTUs.PA,select = colnames(in.soils) )
SB.ts.Soil.richness <- rowSums(SB.ts.Soil.OTUs.PA)
identical(SB.ts.Soil.richness, SB.ts.Soil.richness)


png("figures/sbsoilrichness.png", width = 8, height = 6, res= 500, units = "in")
plot(SB.ts.Soil.richness/SB.ts.richness, type= "l")
dev.off(which = 2)
```


Making a smooth line graph for soil richness

```{r}
#making a data frame for proportion of soil OTUs in SB

SB.ts.Soil.Prop <- tibble(sample.id= env.ts.data$sample.id, date= env.ts.data$date, Soil.Prop= SB.ts.Soil.richness/SB.ts.richness)

#plotting proportion over time

sb.soil.richness.sm <- ggplot(SB.ts.Soil.Prop, aes(x= date, y= Soil.Prop))+
  geom_point()+
  geom_smooth()
ggsave(filename = "figures/sbsoilprop.pdf", plot = sb.soil.richness.sm, height = 6, width = 8) 

```








Classifying Middle OTUs in RG samples, the classification will help focus on a smaller
section of the OTUs closer to the Time series collection to get a better
activity representation instead of far way points which might be too different.

```{r}

RG.middle.OTU <-OTUs.REL[c("RGD08", "RGD09", "RGD10", "RGD11", "RGc08", "RGc09", "RGc10", "RGc11"),]


#OTUs always active
RG.middle.RNA <- as.data.frame(t(colMeans(RG.middle.OTU[str_which(rownames(RG.middle.OTU), "RGc"), ])))
RG.middle.Ac <- RG.middle.RNA[, which(RG.middle.RNA[1, ] > 0)]
RG.avg.ac<- colnames(RG.middle.Ac)
RG.avg.soil.ac <- RG.middle.Ac[, which(colnames(RG.middle.Ac) %in% soil.taxa)]

#OTUs never active
RG.middle.DNA <- as.data.frame(t(colMeans(RG.middle.OTU[str_which(rownames(RG.middle.OTU), "RGD"),])))

 
```



Classifying middle OTUs based on relative abundance
classification helps to see if different classes behave differently in activity patterns
```{r}


RG.clsfd.ac <- RG.middle.Ac |>
  t() |>
  as_tibble() |> 
  rename(rel.ab = V1) |> 
  mutate(ab.class = if_else(rel.ab< exp(-10), 6, 
                            if_else(rel.ab < exp(-9), 5, 
                            if_else(rel.ab < exp(-8), 4, 
                                    if_else(rel.ab < exp(-6), 3, 
                                            if_else(rel.ab < exp(-4), 2, 
                                                    if_else(rel.ab < exp(-2), 1, 12)))))))


row.names(RG.clsfd.ac) <- names(RG.middle.Ac)
RG.clsfd.ac<- rownames_to_column(RG.clsfd.ac, var = "OTU")


```





changing wide form to long form, for code and plot efficiency
```{r}
OTU.ts.long<- UL.ts.OTUs.RNA |> as_tibble() |> 
  rownames_to_column( var= "sample.id" ) |> 
  mutate(sample.id= as.integer(sample.id)) |> 
  pivot_longer(names_to = "OTU", values_to = "relative.abundance", cols = -sample.id) |> 
  left_join(env.ts.data, by= "sample.id" )

OTU.ts.long |> filter(OTU %in% RG.avg.ac) |> 
  filter( OTU %in% soil.taxa) |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()

```





Graphing Soil OTUs based on classification, to get a more readable picture
possibly to see seasonality trends
```{r}

OTU.ts.long |> filter(OTU %in% RG.avg.ac) |> 
  filter(OTU %in% soil.taxa) |>
  left_join(RG.clsfd.ac, by = "OTU") |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()+
  facet_wrap(~ab.class)



OTU.ts.long |> filter(OTU %in% RG.avg.ac) |> 
  filter(!OTU %in% soil.taxa) |>
  left_join(RG.clsfd.ac, by = "OTU") |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  scale_y_log10()+
  facet_wrap(~ab.class)




#getting taxonomy of different rel. abundance classes
clsfd.ac.1<- filter(RG.clsfd.ac, ab.class == 1)
so.ac.1<- OTU.tax |>  
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.1$OTU)

aq.ac.1<- OTU.tax |> 
  filter(!OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.1$OTU)

clsfd.ac.2<- filter(RG.clsfd.ac, ab.class == 2)
so.ac.2<- OTU.tax |> 
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.2$OTU)

aq.ac.2<- OTU.tax |>  
  filter(!OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.2$OTU)

clsfd.ac.3<- filter(RG.clsfd.ac, ab.class == 3)
so.ac.3<- OTU.tax |>  
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.3$OTU)

aq.ac.3<- OTU.tax |>  
  filter(!OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.3$OTU)

clsfd.ac.4<- filter(RG.clsfd.ac, ab.class == 4)
so.ac.4<- OTU.tax |>  
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.4$OTU)

aq.ac.4<- OTU.tax |> 
  filter(!OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.4$OTU)

clsfd.ac.5<- filter(RG.clsfd.ac, ab.class == 5)
so.ac.5<- OTU.tax |> 
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.5$OTU)

aq.ac.5<- OTU.tax |> 
  filter(!OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.5$OTU)

clsfd.ac.6<- filter(RG.clsfd.ac, ab.class == 6)
so.ac.6<- OTU.tax |> 
  filter( OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.6$OTU)

aq.ac.6<- OTU.tax |> 
  filter(!OTU %in% soil.taxa) |>
  filter(OTU %in% clsfd.ac.6$OTU)
  
```







attempting to get sorted RNA and DNA presence absences to recognise clusters.
Checking to see what fraction of OTUs are active at any given time point.
To recognize if a higher or lower fraction of the OTUs are active at different times
possibly hinting at seasonality

```{r}

X0<- as.data.frame(UL.ts.OTUs.RNA.PA[,colSums(UL.ts.OTUs.RNA.PA)>0]) 
X<- data_frame(fraction= rowSums(UL.ts.OTUs.RNA.PA[,colSums(UL.ts.OTUs.RNA.PA)>0])/11824) #only active OTUs
plot(x= rownames(X), y= X$fraction, type = "l")
X1<- data_frame(fraction= rowSums(UL.ts.OTUs.RNA.PA)/83343) #all OTUs
plot(x= rownames(X1), y= X1$fraction, type = "l")

 X2 <- X0 |> 
  subset(X0 %in% rare.in.soils)
 
```


Trying to see the same fractional activity patterns in RNA, DNA, SB datasets
The significant difference between OTUs that were ever present vs all OTUs raises the
question of wether those other OTUs should even be focused on that were never even detected in the data sets
If not detected then, where are they coming from????

**It's from the set of all OTUs that's why 
 
```{r}
X<- data_frame(fraction= rowSums(UL.ts.OTUs.RNA.PA[,colSums(UL.ts.OTUs.RNA.PA)>0])/11824) #Present
plot(x= rownames(X), y= X$fraction, type = "l")
X1<- data_frame(fraction= rowSums(UL.ts.OTUs.RNA.PA)/83343) #All
plot(x= rownames(X1), y= X1$fraction, type = "l")

Y<- data_frame(fraction= rowSums(UL.ts.OTUs.DNA.PA[,colSums(UL.ts.OTUs.DNA.PA)>0])/19399) #Present
plot(x= rownames(Y), y= Y$fraction, type = "l")
Y1<- data_frame(fraction= rowSums(UL.ts.OTUs.DNA.PA)/83343)#ALl
plot(x= rownames(Y1), y= Y1$fraction, type = "l")


```
 
  

filtering data frames to use for clustering

```{r}


Q<- t(UL.ts.OTUs.RNA.PA[ ,colnames(UL.ts.OTUs.RNA.PA) %in% RG.avg.ac])
Q2<- t(data_frame(UL.ts.OTUs.RNA.PA[,colSums(UL.ts.OTUs.RNA.PA)>0]))
Q3<- as.data.frame(UL.ts.OTUs.RNA[,colSums(UL.ts.OTUs.RNA)>0])


```



Making clusters for k=18,found to be best fit from the cluster table created previously.
The aim of clustering was to see different types of activity pattern. Hopefully to recognize
compensation VS complimentary activity patterns in the community. But ended up giving a clearer
visual of seasonality trends.
```{r}
 dist_matrix <-vegdist(Q2, method = "jaccard")

 # Check for missing or infinite values
  if (any(is.na(dist_matrix)) || any(is.infinite(dist_matrix))) {
    # Handle missing or infinite values
    dist_matrix[is.na(dist_matrix) | is.infinite(dist_matrix)] <- 0 } # Replace with 0 or any other appropriate value
    
    # Perform hierarchical clustering
  hclust_result <- hclust(dist_matrix, method = "complete")
  clusters <- cutree(hclust_result, k = 18)
  names(clusters) <- colnames(UL.ts.OTUs.RNA.PA[, colSums(UL.ts.OTUs.RNA.PA) > 0])
  
df<- as.data.frame(t(Q2))
names(df) <- colnames(UL.ts.OTUs.RNA.PA[, colSums(UL.ts.OTUs.RNA.PA) > 0])


clusters.df<- as.data.frame(clusters)
clusters.df$OTU<- rownames(clusters.df)
clusters.df<- clusters.df |> 
  mutate(clusters= as.factor(clusters))
clusters.df |> group_by(clusters) |> 
  count(OTU) |> 
  summarise(sum(count))

OTU.ts.long |> filter(OTU %in% colnames(df)) |> 
  left_join(clusters.df, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters)

```



Filtering based on abundance classes to reduce noise and see the patterns better
Re-clustering after filtering based on abundance class 1
```{r}
df<- as.data.frame(t(Q2))
names(df) <- colnames(UL.ts.OTUs.RNA.PA[, colSums(UL.ts.OTUs.RNA.PA) > 0])
df.1<- df |> select(any_of(clsfd.ac.1$OTU))
dist_matrix.1<- vegdist(t(df.1), method= "jaccard")


# Check for missing or infinite values
if (any(is.na(dist_matrix.1)) || any(is.infinite(dist_matrix.1))) {
  # Handle missing or infinite values
  dist_matrix[is.na(dist_matrix) | is.infinite(dist_matrix)] <- 0  # Replace with 0 or any other appropriate value
}

# Perform hierarchical clustering
hclust_result.1 <- hclust(dist_matrix.1, method = "complete")

# Obtain the clusters for the current iteration
clusters.1 <- cutree(hclust_result.1, k = 3)
sill.1<- silhouette(clusters.1, dist = dist_matrix.1)

# Assign cluster names to the corresponding IDs
names(clusters.1) <- colnames(select(df, any_of(clsfd.ac.1$OTU)))

summary(sill.1)$avg.width

clusters.df.1<- as.data.frame(clusters.1)
clusters.df.1$OTU<- rownames(clusters.df.1)

           
                                        

OTU.ts.long |> filter(OTU %in% colnames(df.1)) |> 
  left_join(clusters.df.1, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters.1)


```







Re-clustering after filtering based on abundance class 2
```{r}
df.2<- df |> select(any_of(clsfd.ac.2$OTU))
dist_matrix.2<- vegdist(t(df.2), method= "jaccard")


# Check for missing or infinite values
if (any(is.na(dist_matrix.2)) || any(is.infinite(dist_matrix.2))) {
  # Handle missing or infinite values
  dist_matrix[is.na(dist_matrix.2) | is.infinite(dist_matrix.2)] <- 0  # Replace with 0 or any other appropriate value
}

# Perform hierarchical clustering
hclust_result.2 <- hclust(dist_matrix.2, method = "complete")

# Obtain the clusters for the current iteration
clusters.2 <- cutree(hclust_result.2, k = 4)
sill.2<- silhouette(clusters.2, dist = dist_matrix.2)

# Assign cluster names to the corresponding IDs
names(clusters.2) <- colnames(select(df, any_of(clsfd.ac.2$OTU)))

summary(sill.2)$avg.width

clusters.df.2<- as.data.frame(clusters.2)
clusters.df.2$OTU<- rownames(clusters.df.2)

           
                                        

OTU.ts.long |> filter(OTU %in% colnames(df.2)) |> 
  left_join(clusters.df.2, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters.2, scales = "free_y")

#selecting OTU names for cluster 2
clusters.2<- as.data.frame(clusters.2)
clusters.2.2 <- as.data.frame(rownames(clusters.2[clusters.2$clusters.2 == 2, , drop= FALSE]))
colnames(clusters.2.2) <- "OTU"


OTU.ts.long |> filter(OTU %in% names(RG.14)) |>
  filter(OTU %in% clusters.2.2[,1]) |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)


```






Re-clustering after filtering based on abundance class 3
```{r}
df.3<- df |> select(any_of(clsfd.ac.3$OTU))
dist_matrix.3<- vegdist(t(df.3), method= "jaccard")


# Check for missing or infinite values
if (any(is.na(dist_matrix.3)) || any(is.infinite(dist_matrix.3))) {
  # Handle missing or infinite values
  dist_matrix[is.na(dist_matrix.3) | is.infinite(dist_matrix.3)] <- 0  # Replace with 0 or any other appropriate value
}

# Perform hierarchical clustering
hclust_result.3 <- hclust(dist_matrix.3, method = "complete")

# Obtain the clusters for the current iteration
clusters.3 <- cutree(hclust_result.3, k = 5)
sill.3<- silhouette(clusters.3, dist = dist_matrix.3)

# Assign cluster names to the corresponding IDs
names(clusters.3) <- colnames(select(df, any_of(clsfd.ac.3$OTU)))

summary(sill.3)$avg.width

clusters.df.3<- as.data.frame(clusters.3)
clusters.df.3$OTU<- rownames(clusters.df.3)

           
                                        

OTU.ts.long |> filter(OTU %in% colnames(df.3)) |> 
  left_join(clusters.df.3, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters.3)

#selecting OTU names for cluster 2
clusters.3<- as.data.frame(clusters.3)
clusters.3.2 <- as.data.frame(rownames(clusters.3[clusters.3$clusters.3 == 2, , drop= FALSE]))
colnames(clusters.3.2) <- "OTU"

#interesting

OTU.ts.long |> filter(OTU %in% names(RG.14)) |>
  filter(OTU %in% clusters.3.2[,1]) |> 
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)

```





Re-clustering after filtering based on abundance class 4
```{r}
df.4<- df |> select(any_of(clsfd.ac.4$OTU))
dist_matrix.4<- vegdist(t(df.4), method= "jaccard")


# Check for missing or infinite values
if (any(is.na(dist_matrix.4)) || any(is.infinite(dist_matrix.4))) {
  # Handle missing or infinite values
  dist_matrix[is.na(dist_matrix.4) | is.infinite(dist_matrix.4)] <- 0  # Replace with 0 or any other appropriate value
}

# Perform hierarchical clustering
hclust_result.4 <- hclust(dist_matrix.4, method = "complete")

# Obtain the clusters for the current iteration
clusters.4 <- cutree(hclust_result.4, k = 4)
sill.4<- silhouette(clusters.4, dist = dist_matrix.4)

# Assign cluster names to the corresponding IDs
names(clusters.4) <- colnames(select(df, any_of(clsfd.ac.4$OTU)))

summary(sill.4)$avg.width

clusters.df.4<- as.data.frame(clusters.4)
clusters.df.4$OTU<- rownames(clusters.df.4)

           
                                        

OTU.ts.long |> filter(OTU %in% colnames(df.4)) |> 
  left_join(clusters.df.4, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters.4)


```




Re-clustering after filtering based on abundance class 5
```{r}
df.5<- df |> select(any_of(clsfd.ac.5$OTU))
dist_matrix.5<- vegdist(t(df.5), method= "jaccard")


# Check for missing or infinite values
if (any(is.na(dist_matrix.5)) || any(is.infinite(dist_matrix.5))) {
  # Handle missing or infinite values
  dist_matrix[is.na(dist_matrix.5) | is.infinite(dist_matrix.5)] <- 0  # Replace with 0 or any other appropriate value
}

# Perform hierarchical clustering
hclust_result.5 <- hclust(dist_matrix.5, method = "complete")

# Obtain the clusters for the current iteration
clusters.5 <- cutree(hclust_result.5, k = 2)
sill.5<- silhouette(clusters.5, dist = dist_matrix.5)

# Assign cluster names to the corresponding IDs
names(clusters.5) <- colnames(select(df, any_of(clsfd.ac.5$OTU)))

summary(sill.5)$avg.width

clusters.df.5<- as.data.frame(clusters.5)
clusters.df.5$OTU<- rownames(clusters.df.5)

           
                                        

OTU.ts.long |> filter(OTU %in% colnames(df.5)) |> 
  left_join(clusters.df.5, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters.5)

```




Re-clustering after filtering based on abundance class 6
```{r}
df.6<- df |> select(any_of(clsfd.ac.6$OTU))
dist_matrix.6<- vegdist(t(df.6), method= "jaccard")


# Check for missing or infinite values
if (any(is.na(dist_matrix.6)) || any(is.infinite(dist_matrix.6))) {
  # Handle missing or infinite values
  dist_matrix[is.na(dist_matrix.6) | is.infinite(dist_matrix.6)] <- 0  # Replace with 0 or any other appropriate value
}

# Perform hierarchical clustering
hclust_result.6 <- hclust(dist_matrix.6, method = "complete")

# Obtain the clusters for the current iteration
clusters.6 <- cutree(hclust_result.6, k = 5)
sill.6<- silhouette(clusters.6, dist = dist_matrix.6)

# Assign cluster names to the corresponding IDs
names(clusters.6) <- colnames(select(df, any_of(clsfd.ac.6$OTU)))

summary(sill.6)$avg.width

clusters.df.6<- as.data.frame(clusters.6)
clusters.df.6$OTU<- rownames(clusters.df.6)

           
                                        

OTU.ts.long |> filter(OTU %in% colnames(df.6)) |> 
  left_join(clusters.df.6, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters.6)

```






Trying clustering based on rel. abundance
```{r}
R2<- t(data_frame(UL.ts.OTUs.RNA[,colSums(UL.ts.OTUs.RNA.PA)>0]))

df.4r<- df |> select(any_of(clsfd.ac.4$OTU))
dist_matrix.4r<- vegdist(t(df.4r), method= "jaccard")


# Check for missing or infinite values
if (any(is.na(dist_matrix.4r)) || any(is.infinite(dist_matrix.4r))) {
  # Handle missing or infinite values
  dist_matrix[is.na(dist_matrix.4r) | is.infinite(dist_matrix.4r)] <- 0  # Replace with 0 or any other appropriate value
}

# Perform hierarchical clustering
hclust_result.4r <- hclust(dist_matrix.4r, method = "complete")

# Obtain the clusters for the current iteration
clusters.4r <- cutree(hclust_result.4r, k = 4)
sill.4r<- silhouette(clusters.4r, dist = dist_matrix.4r)

# Assign cluster names to the corresponding IDs
names(clusters.4r) <- colnames(select(df.4r, any_of(clsfd.ac.4$OTU)))

summary(sill.4r)$avg.width

clusters.df.4r<- as.data.frame(clusters.4r)
clusters.df.4r$OTU<- rownames(clusters.df.4r)

           
                                        

OTU.ts.long |> filter(OTU %in% colnames(df.4r)) |> 
  left_join(clusters.df.4r, by = "OTU") |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~clusters.4r)

```




Plotting soil OTUs detected in transect from soil DNA and RNA

```{r}


RG.all <- unique(c(names(RG.1),names(RG.2),names(RG.3),names(RG.4),names(RG.5),names(RG.6),names(RG.7),
  names(RG.8),names(RG.9),names(RG.10),names(RG.11),names(RG.12),names(RG.13),names(RG.14),names(RG.15),
            names(RG.16),names(RG.17),names(RG.18)))

OTU.ts.long |> filter( OTU %in% RG.all) |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)

#902 soil OTUs active in transect got captured in RNA pool of the time series


RG.D.all <- unique(c(names(RG.D1),names(RG.D2),names(RG.D3),names(RG.D4),names(RG.D5),
                      names(RG.D6),
                     names(RG.D7),names(RG.D8),names(RG.D9),names(RG.D10),names(RG.D11),
                     names(RG.D12),names(RG.D13), names(RG.D14),names(RG.D15),
            names(RG.D16),names(RG.D17),names(RG.D18)))

OTU.ts.long |> filter( OTU %in% RG.D.all) |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)

#942 soil OTUs in transect DNA got captured in RNA pool of the time series



AAC<- UL.ts.OTUs.RNA.PA[, colSums(UL.ts.OTUs.RNA.PA) >0]

AAA<- AAC[,colnames(AAC) %in% RG.D.all]

AAB<- AAC[,colnames(AAC) %in% soil.taxa]

OTU.ts.long |> filter( OTU %in% colnames(AAA)) |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  scale_y_log10()

sample(colnames(AAA), size = 25, replace = FALSE)

OTU.ts.long |> filter( OTU %in% sample(colnames(AAA), size = 25, replace = FALSE)) |>
  ggplot(aes(x= sample.id, y= relative.abundance, group = OTU ))+
  geom_line(alpha = 0.3)+
  facet_wrap(~ OTU, scales = "free_y")

```

